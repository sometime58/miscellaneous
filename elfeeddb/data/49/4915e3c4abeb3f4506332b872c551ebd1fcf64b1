<p>In several places, the C and C++ language specifications use a
curious, and fairly controversial, phrase: <em>undefined behavior</em>. For
certain program constructs, the specification prescribes no specific
behavior, instead allowing <a href="http://www.catb.org/jargon/html/N/nasal-demons.html">anything to happen</a>. Such constructs
are considered erroneous, and so the result depends on the particulars
of the platform and implementation. The original purpose of undefined
behavior was for implementation flexibility. In other words, it’s
slack that allows a compiler to produce appropriate and efficient code
for its target platform.</p>

<p>Specifying a particular behavior would have put unnecessary burden on
implementations — especially in the earlier days of computing — making
for inefficient programs on some platforms. For example, if the result
of dereferencing a null pointer was defined to trap — to cause the
program to halt with an error — then platforms that do not have
hardware trapping, such as those without virtual memory, would be
required to instrument, in software, each pointer dereference.</p>

<p>In the 21st century, undefined behavior has taken on a somewhat
different meaning. Optimizers use it — or <em>ab</em>use it depending on your
point of view — to lift <a href="/blog/2016/12/22/">constraints</a> that would otherwise
inhibit more aggressive optimizations. It’s not so much a
fundamentally different application of undefined behavior, but it does
take the concept to an extreme.</p>

<p>The reasoning works like this: A program that evaluates a construct
whose behavior is undefined cannot, by definition, have any meaningful
behavior, and so that program would be useless. As a result,
<a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">compilers assume programs never invoke undefined behavior</a> and
use those assumptions to prove its optimizations.</p>

<p>Under this newer interpretation, mistakes involving undefined behavior
are more <a href="https://kristerw.blogspot.com/2017/09/why-undefined-behavior-may-call-never.html">punishing</a> and <a href="/blog/2018/05/01/">surprising</a> than before. Programs
that <em>seem</em> to make some sense when run on a particular architecture may
actually compile into a binary with a security vulnerability due to
conclusions reached from an analysis of its undefined behavior.</p>

<p>This can be frustrating if your programs are intended to run on a very
specific platform. In this situation, all behavior really <em>could</em> be
locked down and specified in a reasonable, predictable way. Such a
language would be like an extended, less portable version of C or C++.
But your toolchain still insists on running your program on the
<em>abstract machine</em> rather than the hardware you actually care about.
However, <strong>even in this situation undefined behavior can still be
desirable</strong>. I will provide a couple of examples in this article.</p>

<h3 id="signed-integer-overflow">Signed integer overflow</h3>

<p>To start things off, let’s look at one of my all time favorite examples
of useful undefined behavior, a situation involving signed integer
overflow. The result of a signed integer overflow isn’t just
unspecified, it’s undefined behavior. Full stop.</p>

<p>This goes beyond a simple matter of whether or not the underlying
machine uses a two’s complement representation. From the perspective of
the abstract machine, just the act a signed integer overflowing is
enough to throw everything out the window, even if the overflowed result
is never actually used in the program.</p>

<p>On the other hand, unsigned integer overflow is defined — or, more
accurately, defined to wrap, <em>not</em> overflow. Both the undefined signed
overflow and defined unsigned overflow are useful in different
situations.</p>

<p>For example, here’s a fairly common situation, much like what <a href="https://www.youtube.com/watch?v=yG1OZ69H_-o&amp;t=38m18s">actually
happened in bzip2</a>. Consider this function that does substring
comparison:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">cmp_signed</span><span class="p">(</span><span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i2</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">c2</span><span class="p">;</span>
        <span class="n">i1</span><span class="o">++</span><span class="p">;</span>
        <span class="n">i2</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">cmp_unsigned</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">i2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i2</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">c2</span><span class="p">;</span>
        <span class="n">i1</span><span class="o">++</span><span class="p">;</span>
        <span class="n">i2</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this function, the indices <code class="highlighter-rouge">i1</code> and <code class="highlighter-rouge">i2</code> will always be some small,
non-negative value. Since it’s non-negative, it should be <code class="highlighter-rouge">unsigned</code>,
right? Not necessarily. That puts an extra constraint on code generation
and, at least on x86-64, makes for a less efficient function. Most of
the time you actually <em>don’t</em> want overflow to be defined, and instead
allow the compiler to assume it just doesn’t happen.</p>

<p>The constraint is that <strong>the behavior of <code class="highlighter-rouge">i1</code> or <code class="highlighter-rouge">i2</code> overflowing as an
unsigned integer is defined, and the compiler is obligated to implement
that behavior.</strong> On x86-64, where <code class="highlighter-rouge">int</code> is 32 bits, the result of the
operation must be truncated to 32 bits one way or another, requiring
extra instructions inside the loop.</p>

<p>In the signed case, incrementing the integers cannot overflow since that
would be undefined behavior. This permits the compiler to perform the
increment only in 64-bit precision without truncation if it would be
more efficient, which, in this case, it is.</p>

<p>Here’s the output of Clang 6.0.0 with <code class="highlighter-rouge">-Os</code> on x86-64. Pay close
attention to the main loop, which I named <code class="highlighter-rouge">.loop</code>:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cmp_signed</span><span class="o">:</span>
        <span class="k">movsxd</span> <span class="n">rdi</span><span class="p">,</span> <span class="n">edi</span>             <span class="c">; use i1 as a 64-bit integer</span>
        <span class="k">mov</span>    <span class="n">al</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rdi</span><span class="err">]</span>
        <span class="k">movsxd</span> <span class="n">rsi</span><span class="p">,</span> <span class="n">esi</span>             <span class="c">; use i2 as a 64-bit integer</span>
        <span class="k">mov</span>    <span class="n">cl</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rsi</span><span class="err">]</span>
        <span class="k">jmp</span>    <span class="p">.</span><span class="n">check</span>

<span class="p">.</span><span class="k">loop</span><span class="o">:</span>  <span class="k">mov</span>    <span class="n">al</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rdi</span> <span class="o">+</span> <span class="mi">1</span><span class="err">]</span>
        <span class="k">mov</span>    <span class="n">cl</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rsi</span> <span class="o">+</span> <span class="mi">1</span><span class="err">]</span>
        <span class="k">inc</span>    <span class="n">rdx</span>                  <span class="c">; increment only the base pointer</span>
<span class="p">.</span><span class="n">check</span><span class="o">:</span> <span class="k">cmp</span>    <span class="n">al</span><span class="p">,</span> <span class="n">cl</span>
        <span class="k">je</span>     <span class="p">.</span><span class="k">loop</span>

        <span class="k">movzx</span>  <span class="n">eax</span><span class="p">,</span> <span class="n">al</span>
        <span class="k">movzx</span>  <span class="n">ecx</span><span class="p">,</span> <span class="n">cl</span>
        <span class="k">sub</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">ecx</span>             <span class="c">; return c1 - c2</span>
        <span class="k">ret</span>

<span class="n">cmp_unsigned</span><span class="o">:</span>
        <span class="k">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">edi</span>
        <span class="k">mov</span>    <span class="n">al</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rax</span><span class="err">]</span>
        <span class="k">mov</span>    <span class="n">ecx</span><span class="p">,</span> <span class="n">esi</span>
        <span class="k">mov</span>    <span class="n">cl</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rcx</span><span class="err">]</span>
        <span class="k">cmp</span>    <span class="n">al</span><span class="p">,</span> <span class="n">cl</span>
        <span class="k">jne</span>    <span class="p">.</span><span class="k">ret</span>
        <span class="k">inc</span>    <span class="n">edi</span>
        <span class="k">inc</span>    <span class="n">esi</span>

<span class="p">.</span><span class="k">loop</span><span class="o">:</span>  <span class="k">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">edi</span>             <span class="c">; truncated i1 overflow</span>
        <span class="k">mov</span>    <span class="n">al</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rax</span><span class="err">]</span>
        <span class="k">mov</span>    <span class="n">ecx</span><span class="p">,</span> <span class="n">esi</span>             <span class="c">; truncated i2 overflow</span>
        <span class="k">mov</span>    <span class="n">cl</span><span class="p">,</span> <span class="err">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">rcx</span><span class="err">]</span>
        <span class="k">inc</span>    <span class="n">edi</span>                  <span class="c">; increment i1</span>
        <span class="k">inc</span>    <span class="n">esi</span>                  <span class="c">; increment i2</span>
        <span class="k">cmp</span>    <span class="n">al</span><span class="p">,</span> <span class="n">cl</span>
        <span class="k">je</span>     <span class="p">.</span><span class="k">loop</span>

<span class="p">.</span><span class="k">ret</span><span class="o">:</span>   <span class="k">movzx</span>  <span class="n">eax</span><span class="p">,</span> <span class="n">al</span>
        <span class="k">movzx</span>  <span class="n">ecx</span><span class="p">,</span> <span class="n">cl</span>
        <span class="k">sub</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">ret</span>
</code></pre></div></div>

<p>As unsigned values, <code class="highlighter-rouge">i1</code> and <code class="highlighter-rouge">i2</code> can overflow independently, so they
have to be handled as independent 32-bit unsigned integers. As signed
values they can’t overflow, so they’re treated as if they were 64-bit
integers and, instead, the pointer, <code class="highlighter-rouge">buf</code>, is incremented without
concern for overflow. The signed loop is much more efficient (5
instructions versus 8).</p>

<p>The signed integer helps to communicate the <em>narrow contract</em> of the
function — the limited range of <code class="highlighter-rouge">i1</code> and <code class="highlighter-rouge">i2</code> — to the compiler. In a
variant of C where signed integer overflow is defined (i.e. <code class="highlighter-rouge">-fwrapv</code>),
this capability is lost. In fact, using <code class="highlighter-rouge">-fwrapv</code> deoptimizes the signed
version of this function.</p>

<p>Side note: Using <code class="highlighter-rouge">size_t</code> (an unsigned integer) is even better on x86-64
for this example since it’s already 64 bits and the function doesn’t
need the initial sign/zero extension. However, this might simply move
the sign extension out to the caller.</p>

<h3 id="strict-aliasing">Strict aliasing</h3>

<p>Another controversial undefined behavior is <a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8"><em>strict aliasing</em></a>.
This particular term doesn’t actually appear anywhere in the C
specification, but it’s the popular name for C’s aliasing rules. In
short, variables with types that aren’t compatible are not allowed to
alias through pointers.</p>

<p>Here’s the classic example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// store
</span>    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// store
</span>    <span class="k">return</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span> <span class="c1">// load
</span><span class="p">}</span>
</code></pre></div></div>

<p>Naively one might assume the <code class="highlighter-rouge">return *b</code> could be optimized to a simple
<code class="highlighter-rouge">return 0</code>. However, since <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> have the same type, the compiler
must consider the possibility that they alias — that they point to the
same place in memory — and must generate code that works correctly under
these conditions.</p>

<p>If <code class="highlighter-rouge">foo</code> has a narrow contract that forbids <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> to alias, we
have a couple of options for helping our compiler.</p>

<p>First, we could manually resolve the aliasing issue by returning 0
explicitly. In more complicated functions this might mean making local
copies of values, working only with those local copies, then storing the
results back before returning. Then aliasing would no longer matter.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Second, C99 introduced a <code class="highlighter-rouge">restrict</code> qualifier to communicate to the
compiler that pointers passed to functions cannot alias. For example,
the pointers to <code class="highlighter-rouge">memcpy()</code> are qualified with <code class="highlighter-rouge">restrict</code> as of C99.
Passing aliasing pointers through <code class="highlighter-rouge">restrict</code> parameters is undefined
behavior, e.g. this doesn’t ever happen as far as a compiler is
concerned.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div></div>

<p>The third option is to design an interface that uses incompatible
types, exploiting strict aliasing. This happens all the time, usually
by accident. For example, <code class="highlighter-rouge">int</code> and <code class="highlighter-rouge">long</code> are never compatible even
when they have the same representation.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
</code></pre></div></div>

<p>If you use an extended or modified version of C without strict
aliasing (<code class="highlighter-rouge">-fno-strict-aliasing</code>), then the compiler must assume
everything aliases all the time, generating a lot more precautionary
loads than necessary.</p>

<p>What <a href="https://lkml.org/lkml/2003/2/26/158">irritates</a> a lot of people is that compilers will still
apply the strict aliasing rule even when it’s trivial for the compiler
to prove that aliasing is occurring:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* note: forbidden */</span>
<span class="kt">long</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</code></pre></div></div>

<p>It’s not just a simple matter of making exceptions for these cases.
The language specification would need to define all the rules about
when and where incompatible types are permitted to alias, and
developers would have to understand all these rules if they wanted to
take advantage of the exceptions. It can’t just come down to trusting
that the compiler is smart enough to see the aliasing when it’s
sufficiently simple. It would need to be carefully defined.</p>

<p>Besides, there are probably <a href="https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html">conforming, portable solutions</a>
that, with contemporary compilers, will safely compile to the efficient
code you actually want anyway.</p>

<p>There <em>is</em> one special exception for strict aliasing: <code class="highlighter-rouge">char *</code> is
allowed to alias with anything. This is important to keep in mind both
when you intentionally want aliasing, but also when you want to avoid
it. Writing through a <code class="highlighter-rouge">char *</code> pointer could force the compiler to
generate additional, unnecessary loads.</p>

<p>In fact, there’s a whole dimension to strict aliasing that, even today,
no compiler yet exploits: <code class="highlighter-rouge">uint8_t</code> is not necessarily <code class="highlighter-rouge">unsigned char</code>.
That’s just one possible <code class="highlighter-rouge">typedef</code> definition for it. It could instead
<code class="highlighter-rouge">typedef</code> to, say, some internal <code class="highlighter-rouge">__byte</code> type.</p>

<p>In other words, technically speaking, <code class="highlighter-rouge">uint8_t</code> does not have the strict
aliasing exemption. If you wanted to write bytes to a buffer without
worrying the compiler about aliasing issues with other pointers, this
would be the tool to accomplish it. Unfortunately there’s far too much
existing code that violates this part of strict aliasing that no
toolchain is <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66110">willing to exploit it</a> for optimization purposes.</p>

<h3 id="other-undefined-behaviors">Other undefined behaviors</h3>

<p>Some kinds of undefined behavior don’t have performance or portability
benefits. They’re only there to make the compiler’s job a little
simpler. Today, most of these are caught trivially at compile time as
syntax or semantic issues (i.e. a pointer cast to a float).</p>

<p>Some others are obvious about their performance benefits and don’t
require much explanation. For example, it’s undefined behavior to
index out of bounds (with some special exceptions for one past the
end), meaning compilers are not obligated to generate those checks,
instead relying on the programmer to arrange, by whatever means, that
it doesn’t happen.</p>

<p>Undefined behavior is like nitro, a dangerous, volatile substance that
makes things go really, really fast. You could argue that it’s <em>too</em>
dangerous to use in practice, but the aggressive use of undefined
behavior is <a href="http://thoughtmesh.net/publish/367.php">not without merit</a>.</p>


    