<p>I recently got an itch to design my own non-cryptographic integer hash
function. Firstly, I wanted to <a href="/blog/2017/09/15/">better understand</a> how hash
functions work, and the best way to learn is to do. For years I’d been
treating them like magic, shoving input into it and seeing
<a href="/blog/2018/02/07/">random-looking</a>, but deterministic, output come out the other
end. Just how is the avalanche effect achieved?</p>

<p>Secondly, could I apply my own particular strengths to craft a hash
function better than the handful of functions I could find online?
Especially the classic ones from <a href="https://gist.github.com/badboy/6267743">Thomas Wang</a> and <a href="http://burtleburtle.net/bob/hash/integer.html">Bob
Jenkins</a>. Instead of struggling with the mathematics, maybe I
could software engineer my way to victory, working from the advantage
of access to the excessive computational power of today.</p>

<p>Suppose, for example, I wrote tool to generate a <strong>random hash
function definition</strong>, then <strong>JIT compile it</strong> to a native function in
memory, then execute that function across various inputs to <strong>evaluate
its properties</strong>. My tool could rapidly repeat this process in a loop
until it stumbled upon an incredible hash function the world had never
seen. That’s what I actually did. I call it the <strong>Hash Prospector</strong>:</p>

<p><strong><a href="https://github.com/skeeto/hash-prospector">https://github.com/skeeto/hash-prospector</a></strong></p>

<p>It only works on x86-64 because it uses the same <a href="/blog/2015/03/19/">JIT compiling
technique I’ve discussed before</a>: allocate a page of memory, write
some machine instructions into it, set the page to executable, cast the
page pointer to a function pointer, then call the generated code through
the function pointer.</p>

<h3 id="generating-a-hash-function">Generating a hash function</h3>

<p>My focus is on integer hash functions: a function that accepts an
<em>n</em>-bit integer and returns an <em>n</em>-bit integer. One of the important
properties of an <em>integer</em> hash function is that it maps its inputs to
outputs 1:1. In other words, there are <strong>no collisions</strong>. If there’s a
collision, then some outputs aren’t possible, and the function isn’t
making efficient use of its entropy.</p>

<p>This is actually a lot easier than it sounds. As long as every <em>n</em>-bit
integer operation used in the hash function is <em>reversable</em>, then the
hash function has this property. An operation is reversible if, given
its output, you can unambiguously compute its input.</p>

<p>For example, XOR with a constant is trivially reversible: XOR the
output with the same constant to reverse it. Addition with a constant
is reversed by subtraction with the same constant. Since the integer
operations are modular arithmetic, modulo 2^n for <em>n</em>-bit integers,
multiplication by an <em>odd</em> number is reversible. Odd numbers are
coprime with the power-of-two modulus, so there is some <em>modular
multiplicative inverse</em> that reverses the operation.</p>

<p><a href="http://papa.bretmulvey.com/post/124027987928/hash-functions">Bret Mulvey’s hash function article</a> provides a convenient list
of some reversible operations available for constructing integer hash
functions. This list was the catalyst for my little project. Here are
the ones used by the hash prospector:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span>  <span class="o">=</span> <span class="o">~</span><span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">^=</span> <span class="n">constant</span><span class="p">;</span>
<span class="n">x</span> <span class="o">*=</span> <span class="n">constant</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// e.g. only odd constants
</span><span class="n">x</span> <span class="o">+=</span> <span class="n">constant</span><span class="p">;</span>
<span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">constant</span><span class="p">;</span>
<span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">constant</span><span class="p">;</span>
<span class="n">x</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">constant</span><span class="p">;</span>
<span class="n">x</span> <span class="o">-=</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">constant</span><span class="p">;</span>
<span class="n">x</span> <span class="o">&lt;&lt;&lt;=</span> <span class="n">constant</span><span class="p">;</span> <span class="c1">// left rotation
</span></code></pre></div></div>

<p>I’ve come across a couple more useful operations while studying existing
integer hash functions, but I didn’t put these in the prospector.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hash</span> <span class="o">+=</span> <span class="o">~</span><span class="p">(</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="n">constant</span><span class="p">);</span>
<span class="n">hash</span> <span class="o">-=</span> <span class="o">~</span><span class="p">(</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="n">constant</span><span class="p">);</span>
</code></pre></div></div>

<p>The prospector picks some operations at random and fills in their
constants randomly within their proper constraints. For example,
here’s an awful hash function I made it generate as an example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// do NOT use this!
</span><span class="kt">uint32_t</span>
<span class="nf">badhash32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x1eca7d79</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>
    <span class="n">x</span>  <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
    <span class="n">x</span>  <span class="o">=</span> <span class="o">~</span><span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x10afe4e7</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That function is reversible, and it would be <a href="https://naml.us/post/inverse-of-a-hash-function/">relatively
straightforward</a> to <a href="http://c42f.github.io/2015/09/21/inverting-32-bit-wang-hash.html">define its inverse</a>. However, it has
awful biases and poor avalanche. How do I know this?</p>

<h3 id="the-measure-of-a-hash-function">The measure of a hash function</h3>

<p>There are two key properties I’m looking for in randomly generated hash
functions.</p>

<ol>
  <li>
    <p>High avalanche effect. When I flip one input bit, the output bits
should each flip with a 50% chance.</p>
  </li>
  <li>
    <p>Low bias. Ideally there is no correlation between which output bits
flip for a particular flipped input bit.</p>
  </li>
</ol>

<p>Initially I screwed up and only measured the first property. This lead
to some hash functions that <em>seemed</em> to be amazing before close
inspection, since, for a 32-bit hash function, it was flipping over 15
output bits on average. However, the particular bits being flipped
were heavily biased, resulting in obvious patterns in the output.</p>

<p>For example, when hashing a counter starting from zero, the high bits
would follow a regular pattern. 15 to 16 bits were being flipped each
time, but it was always the same bits.</p>

<p>Conveniently it’s easy to measure both properties at the same time. For
an <em>n</em>-bit integer hash function, create an <em>n</em> by <em>n</em> table initialized
to zero. The rows are input bits and the columns are output bits. The
<em>i</em>th row and <em>j</em>th column track the correlation between the <em>i</em>th input
bit and <em>j</em>th output bit.</p>

<p>Then exhaustively iterate over all 2^n inputs, and flip each bit one at
a time. Increment the appropriate element in the table if the output bit
flips.</p>

<p>When you’re done, ideally each element in the table is exactly 2^(n-1).
That is, each output bit was flipped exactly half the time by each input
bit. Therefore the <em>bias</em> of the hash function is the distance (the
error) of the computed table from the ideal table.</p>

<p>For example, the ideal bias table for an 8-bit hash function would be:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>128 128 128 128 128 128 128 128
128 128 128 128 128 128 128 128
128 128 128 128 128 128 128 128
128 128 128 128 128 128 128 128
128 128 128 128 128 128 128 128
128 128 128 128 128 128 128 128
128 128 128 128 128 128 128 128
128 128 128 128 128 128 128 128
</code></pre></div></div>

<p>The hash prospector computes the standard deviation in order to turn
this into a single, normalized measurement. Lower scores are better.</p>

<p>However, there’s still one problem: the input space for a 32-bit hash
function is over 4 billion values. The full test takes my computer about
an hour and a half. Evaluating a 64-bit hash function is right out.</p>

<p>Again, <a href="/blog/2017/09/21/">Monte Carlo to the rescue</a>! Rather than sample the entire
space, just sample a random subset. This provides a good estimate in
less than a second, allowing lots of terrible hash functions to be
discarded early. The full test can be saved only for the known good
32-bit candidates. 64-bit functions will only ever receive the estimate.</p>

<h3 id="what-did-i-find">What did I find?</h3>

<p>Once I got the bias issue sorted out, and after hours and hours of
running, followed up with some manual tweaking on my part, the
<strong>prospector stumbled across this little gem</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// DO use this one!
</span><span class="kt">uint32_t</span>
<span class="nf">prospector32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x2c1b3c6d</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x297a2d39</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>According to a full (e.g. not estimated) bias evaluation, this function
beats <em>the snot</em> out of most of 32-bit hash functions I could find. It
even comes out ahead of this well known hash function that I <em>believe</em>
originates from the H2 SQL Database. (Update: Thomas Mueller has
confirmed that, indeed, this is his hash function.)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span>
<span class="nf">hash32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">^</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x45d9f3b</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">^</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x45d9f3b</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">^</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s still an excellent hash function, just slightly more biased than
mine.</p>

<p>Very briefly, <code class="highlighter-rouge">prospector32()</code> was the best 32-bit hash function I could
find, and I thought I had a major breakthrough. Then I noticed the
finalizer function for <a href="https://en.wikipedia.org/wiki/MurmurHash#Algorithm">the 32-bit variant of MurmurHash3</a>. It’s
also a 32-bit hash function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span>
<span class="nf">murmurhash32_mix32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x85ebca6b</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0xc2b2ae35</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This one is just <em>barely</em> less biased than mine. So I still haven’t
discovered the best 32-bit hash function, only the <em>second</em> best one.
:-)</p>

<h3 id="a-pattern-emerges">A pattern emerges</h3>

<p>If you’re paying close enough attention, you may have noticed that all
three functions above have the same structure. The prospector had
stumbled upon it all on its own without knowledge of the existing
functions. It may not be so obvious for the second function, but here it
is refactored:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span>
<span class="nf">hash32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x45d9f3b</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x45d9f3b</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I hadn’t noticed this until after the prospector had come across it on
its own. The pattern for all three is XOR-right-shift, multiply,
XOR-right-shift, multiply, XOR-right-shift. There’s something
particularly useful about this <a href="http://www.pcg-random.org/posts/developing-a-seed_seq-alternative.html#multiplyxorshift">multiply-xorshift construction</a>. The
XOR-right-shift diffuses bits rightward and the multiply diffuses bits
leftward. I like to think it’s “sloshing” the bits right, left, right,
left.</p>

<p>It seems that multiplication is particularly good at diffusion, so it
makes perfect sense to exploit it in non-cryptographic hash functions,
especially since modern CPUs are so fast at it. Despite this, it’s not
used much in cryptography due to <a href="http://cr.yp.to/snuffle/design.pdf">issues with completing it in constant
time</a>.</p>

<p>I like to think of this construction in terms of a five-tuple. For the
three functions it’s the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(15, 0x2c1b3c6d, 12, 0x297a2d39, 15)  // prospector32()
(16, 0x045d9f3b, 16, 0x045d9f3b, 16)  // hash32()
(16, 0x85ebca6b, 13, 0xc2b2ae35, 16)  // murmurhash32_mix32()
</code></pre></div></div>

<p>The prospector actually found lots of decent functions following this
pattern, especially where the middle shift is smaller than the outer
shift. Thinking of it in terms of this tuple, I specifically directed
it to try different tuple constants. That’s what I meant by
“tweaking.” Eventually my new function popped out with its really low
bias.</p>

<p>The prospector has a template option (<code class="highlighter-rouge">-p</code>) if you want to try it
yourself:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./prospector -p xorr,mul,xorr,mul,xorr
</code></pre></div></div>

<p>If you really have your heart set on certain constants, such as my
specific selection of shifts, you can lock those in while randomizing
the other constants:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./prospector -p xorr:15,mul,xorr:12,mul,xorr:15
</code></pre></div></div>

<p>Or the other way around:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./prospector -p xorr,mul:2c1b3c6d,xorr,mul:297a2d39,xorr
</code></pre></div></div>

<p>My function seems a little strange using shifts of 15 bits rather than
a nice, round 16 bits. However, changing those constants to 16
increases the bias. Similarly, neither of the two 32-bit constants is
a prime number, but <strong>nudging those constants to the nearest prime
increases the bias</strong>. These parameters really do seem to be a local
minima in the bias, and using prime numbers isn’t important.</p>

<h3 id="what-about-64-bit-integer-hash-functions">What about 64-bit integer hash functions?</h3>

<p>So far I haven’t been able to improve on 64-bit hash functions. The main
function to beat is SplittableRandom / <a href="http://xoshiro.di.unimi.it/splitmix64.c">SplitMix64</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span>
<span class="nf">splittable64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0xbf58476d1ce4e5b9</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">27</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0x94d049bb133111eb</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I also came across <a href="https://gist.github.com/degski/6e2069d6035ae04d5d6f64981c995ec2">this one</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span>
<span class="nf">hash64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0xd6e8feb86659fd93</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT64_C</span><span class="p">(</span><span class="mh">0xd6e8feb86659fd93</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Again, these follow the same construction as before. There really is
something special about it, and many other people have noticed, too.</p>

<p>Both functions have about the same bias. (Remember, I can only estimate
the bias for 64-bit hash functions.) The prospector has found lots of
functions with about the same bias, but nothing provably better. Until
it does, I have no new 64-bit integer hash functions to offer.</p>

<h3 id="string-hash">String hash</h3>

<p>I’m also experimenting with using my hash function as a sort of
primitive for a string hash function. Here I’m using my function in
the loop to mix in one byte at a time, and finishing it with the same
finalizer as MurmurHash3.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span>
<span class="nf">prospector32s</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hash</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
        <span class="n">hash</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x2c1b3c6d</span><span class="p">);</span>
        <span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
        <span class="n">hash</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x297a2d39</span><span class="p">);</span>
        <span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">hash</span> <span class="o">^=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x85ebca6b</span><span class="p">);</span>
    <span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0xc2b2ae35</span><span class="p">);</span>
    <span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">hash</span> <span class="o">+</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It has the typical amount of collisions when running it on a <a href="https://packages.debian.org/sid/wamerican-large">large
dictionary</a>, so it <em>seems</em> decent enough but I don’t know if this
hash function is worth much. More experimentation needed.</p>

<h3 id="beyond-random-search">Beyond random search</h3>

<p>Right now the prospector does a completely random, unstructured search
hoping to stumble upon something good by chance. Perhaps it would be
worth using a genetic algorithm to breed those 5-tuples towards
optimum? Others have had <a href="https://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html">success in this area with simulated
annealing</a>.</p>

<p>There’s probably more to exploit from the multiply-xorshift construction
that keeps popping up. If anything, the prospector is searching too
broadly, looking at constructions that could never really compete no
matter what the constants. In addition to everything above, I’ve been
looking for good 32-bit hash functions that don’t use any 32-bit
constants, but I’m really not finding any with a competitively low bias.</p>

<h3 id="update-after-one-week">Update after one week</h3>

<p>About one week after publishing this article I found an even better hash
function. I believe <strong>this is the least biased 32-bit integer hash
function <em>of this form</em> ever devised</strong>. It’s even less biased than the
MurmurHash3 finalizer.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// exact bias: 0.17353355999581582
</span><span class="kt">uint32_t</span>
<span class="nf">lowbias32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x7feb352d</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x846ca68b</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// inverse
</span><span class="kt">uint32_t</span>
<span class="nf">lowbias32_r</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x43021123</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span> <span class="o">^</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x1d69e2a5</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If you’re willing to use an additional round of multiply-xorshift, this
next function actually reaches the theoretical bias limit (bias =
~0.021) as exhibited by a perfect integer hash function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// exact bias: 0.020888578919738908
</span><span class="kt">uint32_t</span>
<span class="nf">triple32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0xed5ad4bb</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0xac4c1b51</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">UINT32_C</span><span class="p">(</span><span class="mh">0x31848bab</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s statistically indistinguishable from a random permutation of all
32-bit integers.</p>


    