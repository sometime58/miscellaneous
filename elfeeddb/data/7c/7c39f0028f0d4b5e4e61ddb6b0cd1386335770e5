<p>The <code class="highlighter-rouge">ptrace(2)</code> (“process trace”) system call is usually associated with
debugging. It’s the primary mechanism through which native debuggers
monitor debuggees on unix-like systems. It’s also the usual approach for
implementing <a href="https://blog.plover.com/Unix/strace-groff.html">strace</a> — system call trace. With Ptrace, tracers
can pause tracees, <a href="/blog/2016/09/03/">inspect and set registers and memory</a>, monitor
system calls, or even <em>intercept</em> system calls.</p>

<p>By intercept, I mean that the tracer can mutate system call arguments,
mutate the system call return value, or even block certain system calls.
Reading between the lines, this means a tracer can fully service system
calls itself. This is particularly interesting because it also means <strong>a
tracer can emulate an entire foreign operating system</strong>. This is done
without any special help from the kernel beyond Ptrace.</p>

<p>The catch is that a process can only have one tracer attached at a time,
so it’s not possible emulate a foreign operating system while also
debugging that process with, say, GDB. The other issue is that emulated
systems calls will have higher overhead.</p>

<p>For this article I’m going to focus on <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html">Linux’s Ptrace</a> on
x86-64, and I’ll be taking advantage of a few Linux-specific extensions.
For the article I’ll also be omitting error checks, but the full source
code listings will have them.</p>

<p>You can find runnable code for the examples in this article here:</p>

<p><strong><a href="https://github.com/skeeto/ptrace-examples">https://github.com/skeeto/ptrace-examples</a></strong></p>

<h3 id="strace">strace</h3>

<p>Before getting into the really interesting stuff, let’s start by
reviewing a bare bones implementation of strace. It’s <a href="/blog/2018/01/17/">no
DTrace</a>, but strace is still incredibly useful.</p>

<p>Ptrace has never been standardized. Its interface is similar across
different operating systems, especially in its core functionality, but
it’s still subtly different from system to system. The <code class="highlighter-rouge">ptrace(2)</code>
prototype generally looks something like this, though the specific
types may be different.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">ptrace</span><span class="p">(</span><span class="kt">int</span> <span class="n">request</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">pid</code> is the tracee’s process ID. While a tracee can have only one
tracer attached at a time, a tracer can be attached to many tracees.</p>

<p>The <code class="highlighter-rouge">request</code> field selects a specific Ptrace function, just like the
<code class="highlighter-rouge">ioctl(2)</code> interface. For strace, only two are needed:</p>

<ul>
  <li><code class="highlighter-rouge">PTRACE_TRACEME</code>: This process is to be traced by its parent.</li>
  <li><code class="highlighter-rouge">PTRACE_SYSCALL</code>: Continue, but stop at the next system call
entrance or exit.</li>
  <li><code class="highlighter-rouge">PTRACE_GETREGS</code>: Get a copy of the tracee’s registers.</li>
</ul>

<p>The other two fields, <code class="highlighter-rouge">addr</code> and <code class="highlighter-rouge">data</code>, serve as generic arguments for
the selected Ptrace function. One or both are often ignored, in which
case I pass zero.</p>

<p>The strace interface is essentially a prefix to another command.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ strace [strace options] program [arguments]
</code></pre></div></div>

<p>My minimal strace doesn’t have any options, so the first thing to do —
assuming it has at least one argument — is <code class="highlighter-rouge">fork(2)</code> and <code class="highlighter-rouge">exec(2)</code> the
tracee process on the tail of <code class="highlighter-rouge">argv</code>. But before loading the target
program, the new process will inform the kernel that it’s going to be
traced by its parent. The tracee will be paused by this Ptrace system
call.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="cm">/* error */</span>
        <span class="n">FATAL</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>  <span class="cm">/* child */</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_TRACEME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">execvp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">FATAL</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The parent waits for the child’s <code class="highlighter-rouge">PTRACE_TRACEME</code> using <code class="highlighter-rouge">wait(2)</code>. When
<code class="highlighter-rouge">wait(2)</code> returns, the child will be paused.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Before allowing the child to continue, we tell the operating system that
the tracee should be terminated along with its parent. A real strace
implementation may want to set other options, such as
<code class="highlighter-rouge">PTRACE_O_TRACEFORK</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETOPTIONS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PTRACE_O_EXITKILL</span><span class="p">);</span>
</code></pre></div></div>

<p>All that’s left is a simple, endless loop that catches on system calls
one at a time. The body of the loop has four steps:</p>

<ol>
  <li>Wait for the process to enter the next system call.</li>
  <li>Print a representation of the system call.</li>
  <li>Allow the system call to execute and wait for the return.</li>
  <li>Print the system call return value.</li>
</ol>

<p>The <code class="highlighter-rouge">PTRACE_SYSCALL</code> request is used in both waiting for the next system
call to begin, and waiting for that system call to exit. As before, a
<code class="highlighter-rouge">wait(2)</code> is needed to wait for the tracee to enter the desired state.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>When <code class="highlighter-rouge">wait(2)</code> returns, the registers for the thread that made the
system call are filled with the system call number and its arguments.
However, <em>the operating system has not yet serviced this system call</em>.
This detail will be important later.</p>

<p>The next step is to gather the system call information. This is where
it gets architecture specific. On x86-64, <a href="/blog/2015/05/15/">the system call number is
passed in <code class="highlighter-rouge">rax</code></a>, and the arguments (up to 6) are passed in
<code class="highlighter-rouge">rdi</code>, <code class="highlighter-rouge">rsi</code>, <code class="highlighter-rouge">rdx</code>, <code class="highlighter-rouge">r10</code>, <code class="highlighter-rouge">r8</code>, and <code class="highlighter-rouge">r9</code>. Reading the registers is
another Ptrace call, though there’s no need to <code class="highlighter-rouge">wait(2)</code> since the
tracee isn’t changing state.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>
<span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">syscall</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">orig_rax</span><span class="p">;</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%ld(%ld, %ld, %ld, %ld, %ld, %ld)"</span><span class="p">,</span>
        <span class="n">syscall</span><span class="p">,</span>
        <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">rdi</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">rsi</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">rdx</span><span class="p">,</span>
        <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">r10</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">r8</span><span class="p">,</span>  <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">r9</span><span class="p">);</span>
</code></pre></div></div>

<p>There’s one caveat. For <a href="https://stackoverflow.com/a/6469069">internal kernel purposes</a>, the system
call number is stored in <code class="highlighter-rouge">orig_rax</code> rather than <code class="highlighter-rouge">rax</code>. All the other
system call arguments are straightforward.</p>

<p>Next it’s another <code class="highlighter-rouge">PTRACE_SYSCALL</code> and <code class="highlighter-rouge">wait(2)</code>, then another
<code class="highlighter-rouge">PTRACE_GETREGS</code> to fetch the result. The result is stored in <code class="highlighter-rouge">rax</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">" = %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">.</span><span class="n">rax</span><span class="p">);</span>
</code></pre></div></div>

<p>The output from this simple program is <em>very</em> crude. There is no
symbolic name for the system call and every argument is printed
numerically, even if it’s a pointer to a buffer. A more complete strace
would know which arguments are pointers and use <code class="highlighter-rouge">process_vm_readv(2)</code> to
read those buffers from the tracee in order to print them appropriately.</p>

<p>However, this does lay the groundwork for system call interception.</p>

<h3 id="system-call-interception">System call interception</h3>

<p>Suppose we want to use Ptrace to implement something like OpenBSD’s
<a href="https://man.openbsd.org/pledge.2"><code class="highlighter-rouge">pledge(2)</code></a>, in which <a href="http://www.openbsd.org/papers/hackfest2015-pledge/mgp00001.html">a process <em>pledges</em> to use only a
restricted set of system calls</a>. The idea is that many
programs typically have an initialization phase where they need lots
of system access (opening files, binding sockets, etc.). After
initialization they enter a main loop in which they processing input
and only a small set of system calls are needed.</p>

<p>Before entering this main loop, a process can limit itself to the few
operations that it needs. If <a href="/blog/2017/07/19/">the program has a flaw</a> allowing it
to be exploited by bad input, the pledge significantly limits what the
exploit can accomplish.</p>

<p>Using the same strace model, rather than print out all system calls,
we could either block certain system calls or simply terminate the
tracee when it misbehaves. Termination is easy: just call <code class="highlighter-rouge">exit(2)</code> in
the tracer. Since it’s configured to also terminate the tracee.
Blocking the system call and allowing the child to continue is a
little trickier.</p>

<p>The tricky part is that <strong>there’s no way to abort a system call once
it’s started</strong>. When tracer returns from <code class="highlighter-rouge">wait(2)</code> on the entrance to
the system call, the only way to stop a system call from happening is
to terminate the tracee.</p>

<p>However, not only can we mess with the system call arguments, we can
change the system call number itself, converting it to a system call
that doesn’t exist. On return we can report a “friendly” <code class="highlighter-rouge">EPERM</code> error
in <code class="highlighter-rouge">errno</code> <a href="/blog/2016/09/23/">via the normal in-band signaling</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="cm">/* Enter next system call */</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>

    <span class="cm">/* Is this system call permitted? */</span>
    <span class="kt">int</span> <span class="n">blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_syscall_blocked</span><span class="p">(</span><span class="n">regs</span><span class="p">.</span><span class="n">orig_rax</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">regs</span><span class="p">.</span><span class="n">orig_rax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// set to invalid syscall
</span>        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Run system call and stop on exit */</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSCALL</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* errno = EPERM */</span>
        <span class="n">regs</span><span class="p">.</span><span class="n">rax</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span> <span class="c1">// Operation not permitted
</span>        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This simple example only checks against a whitelist or blacklist of
system calls. And there’s no nuance, such as allowing files to be
opened (<code class="highlighter-rouge">open(2)</code>) read-only but not as writable, allowing anonymous
memory maps but not non-anonymous mappings, etc. There’s also no way
to the tracee to dynamically drop privileges.</p>

<p>How <em>could</em> the tracee communicate to the tracer? Use an artificial
system call!</p>

<h3 id="creating-an-artificial-system-call">Creating an artificial system call</h3>

<p>For my new pledge-like system call — which I call <code class="highlighter-rouge">xpledge()</code> to
distinguish it from the real thing — I picked system call number 10000,
a nice high number that’s unlikely to ever be used for a real system
call.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SYS_xpledge 10000
</span></code></pre></div></div>

<p>Just for demonstration purposes, I put together a minuscule interface
that’s not good for much in practice. It has little in common with
OpenBSD’s <code class="highlighter-rouge">pledge(2)</code>, which uses a <a href="https://www.tedunangst.com/flak/post/string-interfaces">string interface</a>.
<em>Actually</em> designing robust and secure sets of privileges is really
complicated, as the <code class="highlighter-rouge">pledge(2)</code> manpage shows. Here’s the entire
interface <em>and</em> implementation of the system call for the tracee:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GNU_SOURCE
#include &lt;unistd.h&gt;
</span>
<span class="cp">#define XPLEDGE_RDWR  (1 &lt;&lt; 0)
#define XPLEDGE_OPEN  (1 &lt;&lt; 1)
</span>
<span class="cp">#define xpledge(arg) syscall(SYS_xpledge, arg)
</span></code></pre></div></div>

<p>If it passes zero for the argument, only a few basic system calls are
allowed, including those used to allocate memory (e.g. <code class="highlighter-rouge">brk(2)</code>). The
<code class="highlighter-rouge">PLEDGE_RDWR</code> bit allows <a href="/blog/2017/03/01/">various</a> read and write system calls
(<code class="highlighter-rouge">read(2)</code>, <code class="highlighter-rouge">readv(2)</code>, <code class="highlighter-rouge">pread(2)</code>, <code class="highlighter-rouge">preadv(2)</code>, etc.). The
<code class="highlighter-rouge">PLEDGE_OPEN</code> bit allows <code class="highlighter-rouge">open(2)</code>.</p>

<p>To prevent privileges from being escalated back, <code class="highlighter-rouge">pledge()</code> blocks
itself — though this also prevents dropping more privileges later down
the line.</p>

<p>In the xpledge tracer, I just need to check for this system call:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Handle entrance */</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">regs</span><span class="p">.</span><span class="n">orig_rax</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SYS_pledge</span><span class="p">:</span>
        <span class="n">register_pledge</span><span class="p">(</span><span class="n">regs</span><span class="p">.</span><span class="n">rdi</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The operating system will return <code class="highlighter-rouge">ENOSYS</code> (Function not implemented)
since this isn’t a <em>real</em> system call. So on the way out I overwrite
this with a success (0).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Handle exit */</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">regs</span><span class="p">.</span><span class="n">orig_rax</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SYS_pledge</span><span class="p">:</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEUSER</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">RAX</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I wrote a little test program that opens <code class="highlighter-rouge">/dev/urandom</code>, makes a read,
tries to pledge, then tries to open <code class="highlighter-rouge">/dev/urandom</code> a second time, then
confirms it can read from the original <code class="highlighter-rouge">/dev/urandom</code> file descriptor.
Running without a pledge tracer, the output looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./example
fread("/dev/urandom")[1] = 0xcd2508c7
XPledging...
XPledge failed: Function not implemented
fread("/dev/urandom")[2] = 0x0be4a986
fread("/dev/urandom")[1] = 0x03147604
</code></pre></div></div>

<p>Making an invalid system call doesn’t crash an application. It just
fails, which is a rather convenient fallback. When run under the
tracer, it looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./xpledge ./example
fread("/dev/urandom")[1] = 0xb2ac39c4
XPledging...
fopen("/dev/urandom")[2]: Operation not permitted
fread("/dev/urandom")[1] = 0x2e1bd1c4
</code></pre></div></div>

<p>The pledge succeeds but the second <code class="highlighter-rouge">fopen(3)</code> does not since the tracer
blocked it with <code class="highlighter-rouge">EPERM</code>.</p>

<p>This concept could be taken much further, to, say, change file paths or
return fake results. A tracer could effectively chroot its tracee,
prepending some chroot path to the root of any path passed through a
system call. It could even lie to the process about what user it is,
claiming that it’s running as root. In fact, this is exactly how the
<a href="https://fakeroot-ng.lingnu.com/index.php/Home_Page">Fakeroot NG</a> program works.</p>

<h3 id="foreign-system-emulation">Foreign system emulation</h3>

<p>Suppose you don’t just want to intercept <em>some</em> system calls, but
<em>all</em> system calls. You’ve got <a href="/blog/2017/11/30/">a binary intended to run on another
operating system</a>, so none of the system calls it makes will ever
work.</p>

<p>You could manage all this using only what I’ve described so far. The
tracer would always replace the system call number with a dummy, allow
it to fail, then service the system call itself. But that’s really
inefficient. That’s essentially three context switches for each system
call: one to stop on the entrance, one to make the always-failing
system call, and one to stop on the exit.</p>

<p>The Linux version of PTrace has had a more efficient operation for
this technique since 2005: <code class="highlighter-rouge">PTRACE_SYSEMU</code>. PTrace stops only <em>once</em>
per a system call, and it’s up to the tracer to service that system
call before allowing the tracee to continue.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSEMU</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">user_regs_struct</span> <span class="n">regs</span><span class="p">;</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">regs</span><span class="p">.</span><span class="n">orig_rax</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">OS_read</span><span class="p">:</span>
            <span class="cm">/* ... */</span>

        <span class="k">case</span> <span class="n">OS_write</span><span class="p">:</span>
            <span class="cm">/* ... */</span>

        <span class="k">case</span> <span class="n">OS_open</span><span class="p">:</span>
            <span class="cm">/* ... */</span>

        <span class="k">case</span> <span class="n">OS_exit</span><span class="p">:</span>
            <span class="cm">/* ... */</span>

        <span class="cm">/* ... and so on ... */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To run binaries for the same architecture from any system with a
stable (enough) system call ABI, you just need this <code class="highlighter-rouge">PTRACE_SYSEMU</code>
tracer, a loader (to take the place of <code class="highlighter-rouge">exec(2)</code>), and whatever system
libraries the binary needs (or only run static binaries).</p>

<p>In fact, this sounds like a fun weekend project.</p>

<h3 id="see-also">See also</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=uXgxMDglxVM">Implementing a clone of OpenBSD pledge into the Linux kernel</a></li>
</ul>


    